{"version":3,"sources":["../../../src/stomp/stomp-frame-parser.ts"],"names":[],"mappings":"AAAA,sDAAsD;AACtD,OAAO,EAAc,YAAY,EAAE,UAAU,EAAC,MAAM,eAAe,CAAC;AAGpE,MAAM,CAAC,IAAM,IAAI,GAAG;IAClB,2BAA2B;IAC3B,EAAE,EAAE,MAAM;IACV,sBAAsB;IACtB,IAAI,EAAE,MAAM;CACb,CAAC;AAEF;;GAEG;AACH;IAAA;IAsGA,CAAC;IAnGQ,mDAAkB,GAAzB,UAA0B,OAAa;QACrC,IAAI,IAAY,CAAC;QACjB,EAAE,CAAC,CAAC,OAAO,WAAW,IAAI,OAAO,YAAY,WAAW,CAAC,CAAC,CAAC;YACzD,IAAI,GAAG,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC;YAClC,OAAO,CAAC,GAAG,CAAC,uBAAuB,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;YACjD,IAAI,aAAW,GAAa,EAAE,CAAC;YAC/B,GAAG,CAAC,OAAO,CAAC,UAAA,GAAG,IAAI,OAAA,aAAW,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,EAA1C,CAA0C,CAAC,CAAC;YAC/D,IAAI,GAAG,aAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC9B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,iDAAiD;YACjD,IAAI,GAAG,OAAO,CAAC;QACjB,CAAC;QAED,0EAA0E;QAC1E,EAAE,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;YACrB,OAAO,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAC;YACvC,MAAM,CAAC;QACT,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;IAGO,kDAAiB,GAAzB,UAA0B,IAAY;QACpC,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,MAAG,CAAC,CAAC;QAEnD,IAAI,MAAM,GAAgB;YACxB,MAAM,EAAE,EAAE;YACV,OAAO,EAAE,EAAE;SACZ,CAAC;QAEF,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3C,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACvD,CAAC;QAED,IAAI,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC1C,EAAE,CAAC,CAAC,SAAS,KAAK,IAAI,CAAC,EAAE,IAAI,SAAS,CAAC,MAAM,CAAC,KAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,OAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACjF,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACvE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,OAAO,GAAG,SAAS,CAAC;QAC7B,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAEO,iDAAgB,GAAxB,UAAyB,IAAY;QAEnC,IAAI,CAAC;YACH,+EAA+E;YAC/E,0DAA0D;YAC1D,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;YACxC,IAAI,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAE5D,kCAAkC;YAClC,4CAA4C;YAE5C,IAAI,UAAU,GAAY,WAAW,CAAC,KAAK,EAAE,CAAC;YAC9C,IAAI,OAAO,GAAG,IAAI,GAAG,EAAiB,CAAC;YACvC,IAAI,IAAI,GAAW,EAAE,CAAC;YAEtB,GAAG,CAAC,CAAa,UAAqB,EAArB,KAAA,WAAW,CAAC,OAAO,EAAE,EAArB,cAAqB,EAArB,IAAqB;gBAAjC,IAAI,IAAI,SAAA;gBACX,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC5B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;aACnF;YAED,6DAA6D;YAC7D,IAAI,KAAK,GAAG,OAAO,GAAG,CAAC,CAAC;YACxB,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;gBAClC,IAAI,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBAClD,IAAI,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,GAAG,CAAC,CAAC;YACnD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,GAAG,GAAW,IAAI,CAAC;gBACvB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACrC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBACrB,EAAE,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;wBACtB,KAAK,CAAC;oBACR,CAAC;oBACD,IAAI,IAAI,GAAG,CAAC;gBACd,CAAC;YACH,CAAC;YACD,MAAM,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QACtE,CAAC;QAAA,KAAK,CAAA,CAAC,GAAG,CAAC,CAAA,CAAC;YACV,8BAA8B;YAC9B,OAAO,CAAC,IAAI,CAAC,wBAAwB,EAAE,IAAI,CAAC,CAAC;YAC7C,MAAM,GAAG,CAAC;QACZ,CAAC;IACH,CAAC;IAEO,6CAAY,GAApB,UAAqB,UAAiB;QACpC,EAAE,CAAA,CAAC,CAAC,UAAU,CAAC;YAAC,MAAM,IAAI,KAAK,CAAC,mFAAmF,CAAC,CAAA;QACpH,IAAI,OAAO,GAAG,YAAY,CAAC,UAAuC,CAAC,CAAC;QACpE,EAAE,CAAA,CAAC,CAAC,OAAO,CAAC,CAAA,CAAC;YACX,MAAM,IAAI,KAAK,CAAC,8BAA4B,UAAU,4BAAyB,CAAC,CAAC;QACnF,CAAC;QACD,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;IAEO,qCAAI,GAAZ,UAAa,KAAa;QACxB,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;IACzC,CAAC;IACH,6BAAC;AAAD,CAtGA,AAsGC,IAAA;;AAGD;;GAEG;AACH;IAAA;IAkDA,CAAC;IAhDC;;;;;OAKG;IACI,wCAAS,GAAhB,UAAiB,KAAkB;QACjC,IAAI,UAAU,GAAG,YAAY,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAI,KAAK,GAAa,CAAC,UAAU,CAAC,CAAC;QAEnC,IAAI,iBAAiB,GAAG,KAAK,CAAC;QAE9B;;;;WAIG;QAEH,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC;YACrC,KAAK,CAAC,SAAS,CAAC,gBAAgB,EAAE,oBAAoB,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,GAAC,EAAE,CAAC,CAAC;QACvF,CAAC;QACD,KAAK,CAAC,aAAa,CAAC,UAAC,KAAK,EAAE,GAAG,IAAK,OAAA,KAAK,CAAC,IAAI,CAAI,GAAG,SAAI,KAAO,CAAC,EAA7B,CAA6B,CAAC,CAAC;QAEnE,IAAI,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAEjC,IAAI,OAAO,GAAG,MAAM,GAAG,IAAI,CAAC,EAAE,GAAC,IAAI,CAAC,EAAE,CAAC;QAEvC,EAAE,CAAA,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA,CAAC;YACb,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC;QACxB,CAAC;QACD,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC;QAErB,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;IAED;;;;;;OAMG;IACY,kCAAa,GAA5B,UAA6B,KAAa;QACxC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;QACjD,CAAC;QACD,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;IACH,2BAAC;AAAD,CAlDA,AAkDC,IAAA","file":"stomp-frame-parser.js","sourceRoot":"","sourcesContent":["// Define constants for bytes used throughout the code\nimport {FrameBuffer, StompCommand, StompFrame} from \"./stomp-frame\";\n\n\nexport const BYTE = {\n  // LINEFEED byte (octet 10)\n  LF: '\\x0A',\n  // NULL byte (octet 0)\n  NULL: '\\x00'\n};\n\n/**\n * Provides the ability to parse a message into frame(s)\n */\nexport class StompFrameDeserializer {\n\n\n  public deserializeMessage(message : any){\n    let data: string;\n    if (typeof ArrayBuffer && message instanceof ArrayBuffer) {\n      let arr = new Uint8Array(message);\n      console.log('--- got data length: ', arr.length);\n      let stringArray: string[] = [];\n      arr.forEach(val => stringArray.push(String.fromCharCode(val)));\n      data = stringArray.join('');\n    } else {\n      // take data directly from WebSocket 'data' field\n      data = message;\n    }\n\n    // If heart-beats are requested and no real frame is sent, EOL is expected\n    if (data === BYTE.LF) {\n      console.log('<<< heart-beat received');\n      return;\n    }\n\n    return this.deserializeFrames(data);\n  }\n\n\n  private deserializeFrames(data: string) : FrameBuffer {\n    let frames = data.split(`${BYTE.NULL}${BYTE.LF}*`);\n\n    let buffer: FrameBuffer = {\n      frames: [],\n      partial: ''\n    };\n\n    for (let i = 0; i < frames.length - 1; i++) {\n      buffer.frames.push(this.deserializeFrame(frames[i]));\n    }\n\n    let lastFrame = frames[frames.length - 1];\n    if (lastFrame === BYTE.LF || lastFrame.search(`${BYTE.NULL}${BYTE.LF}*$`) !== -1) {\n      buffer.frames.push(this.deserializeFrame(frames[frames.length - 1]));\n    } else {\n      buffer.partial = lastFrame;\n    }\n    return buffer;\n  }\n\n  private deserializeFrame(data: string) : StompFrame {\n\n    try {\n      // search for 2 consecutive LF bytes to split command and headers from the body\n      //let divider = data.search(`///${BYTE.LF}${BYTE.LF}///`);\n      let divider = data.search('\\n\\r?\\n\\r?');\n      let headerLines = data.substring(0, divider).split(BYTE.LF);\n\n      //console.log('console', divider);\n      //console.log(\"data chars\", data.split(''));\n\n      let commandStr : string = headerLines.shift();\n      let headers = new Map<string,string>();\n      let body: string = '';\n\n      for (let line of headerLines.reverse()) {\n        let idx = line.indexOf(':');\n        headers.set(this.trim(line.substring(0, idx)), this.trim(line.substring(idx + 1)))\n      }\n\n      // skip the 2 LF bytes that divides the headers from the body\n      let start = divider + 2;\n      if (headers.get('content-length')) {\n        let len = parseInt(headers.get('content-length'));\n        body = ('' + data).substring(start, start + len);\n      } else {\n        let chr: string = null;\n        for (let i = 0; i < data.length; i++) {\n          chr = data.charAt(i);\n          if (chr === BYTE.NULL) {\n            break;\n          }\n          body += chr;\n        }\n      }\n      return new StompFrame(this.parseCommand(commandStr), body, headers);\n    }catch(err){\n      // Failed to deserialize frame\n      console.warn(\"Failed to parse frame:\", data);\n      throw err;\n    }\n  }\n\n  private parseCommand(commandStr:string) : StompCommand{\n    if(!commandStr) throw new Error(\"ArgumentNullException: commandStr was 'null' which is not a valid command string!\")\n    let command = StompCommand[commandStr as keyof typeof StompCommand];\n    if(!command){\n      throw new Error(`Could not parse command '${commandStr}' into a STOMP command!`);\n    }\n    return command;\n  }\n\n  private trim(value: string) : string {\n    return value.replace(/^\\s+|\\s+$/g, '');\n  }\n}\n\n\n/**\n * Provides the ability to serialize a stomp frame\n */\nexport class StompFrameSerializer{\n\n  /**\n   * Computes a textual representation of the frame.\n   * Suitable to be sent to the server\n   *\n   * @returns {string} A textual representation of the frame\n   */\n  public serialize(frame : StompFrame): string {\n    let commandStr = StompCommand[frame.command];\n    let lines: string[] = [commandStr];\n\n    let skipContentLength = false;\n\n    /*\n    skipContentLength = <boolean>frame.getHeader('content-length');\n    if (skipContentLength) {\n      delete frame.headers['content-length'];\n    }*/\n\n    if (frame.body && !skipContentLength) {\n      frame.setHeader('content-length', StompFrameSerializer.getUTF8Length(frame.body)+'');\n    }\n    frame.foreachHeader((value, key) => lines.push(`${key}:${value}`));\n\n    let header = lines.join(BYTE.LF);\n\n    let content = header + BYTE.LF+BYTE.LF;\n\n    if(frame.body){\n      content += frame.body;\n    }\n    content += BYTE.NULL;\n\n    return content;\n  }\n\n  /**\n   * Compute the size of a UTF-8 string by counting its number of bytes\n   * (and not the number of characters composing the string)\n   *\n   * @param {string} value\n   * @returns {number} number of bytes in the string\n   */\n  private static getUTF8Length(value: string): number {\n    if (value) {\n      return encodeURI(value).match(/%..|./g).length;\n    }\n    return 0;\n  }\n}\n"]}